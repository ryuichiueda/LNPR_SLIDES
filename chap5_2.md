$\newcommand{\V}[1]{\boldsymbol{#1}}$

# 5. パーティクル<br />フィルタによる<br />自己位置推定<br />（後半）

千葉工業大学 上田 隆一

<br />

<p style="font-size:50%">
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
</p>

---

## 5.4 観測後のセンサ値の反映

* やること: センサ値の持つ情報をパーティクルの分布に<br />反映する
    * ベイズの定理を利用

---

## 5.4.1 準備 

作業なので省略

---

## 5.4.2 センサ値による<br />パーティクルの姿勢の評価

* センサ値$\V{z}_j$が得られたときに、ふたつのパーティクル$\V{x}^{(i)}, \V{x}^{(k)}$のどっちがどれだけ真値としてふさわしい？<br />　
* 観測モデル$p_j (\V{z}_j | \V{x})$の比で数値化可能
    * 例: $p_j (\V{z}_j | \V{x}^{(i)}) = 0.02, p_j (\V{z}_j | \V{x}^{(k)}) = 0.01$なら<br />$\V{x}^{(i)}$の方が$\V{x}^{(k)}$より2倍<span style="color:red">尤もらしい</span>
    * $0.02$や$0.01$は確率ではないが確率的な比較は可能
    * 比: <span style="color:red">尤度比</span>、数値: <span style="color:red">尤度</span><br />　
* 観測モデル$p_j (\V{z}_j | \V{x})$は状態遷移モデルのときと同様、<br />実験などで特定（後述）


---

### 尤度関数

* $p_j (\V{z}_j | \V{x})$について$\V{x}$を変数とみなす$\Longrightarrow$<span style="color:red">尤度関数</span><br />
    * $L_j(\V{x} | \V{z}_j ) = \eta p_j (\V{z}_j | \V{x})$
        * $\eta$は正ならなんでもよい（比でしか利用しないので）
        * 条件（パラメータ）と変数が入れ替わっただけで同じ式<br />　
* ベイズの定理との関係
    * あえて尤度を使って考察したが、<br />今の議論はベイズの定理でも説明可能
    * $b\_t(\V{x}\_t^{(i)}) = \hat{b}\_t(\V{x}\_t^{(i)} | \V{z}\_{j,t}) = \eta p\_j(\V{z}\_{j,t} | \V{x}\_t^{(i)}) \hat{b}\_t(\V{x}\_t^{(i)}) \\\\ = \eta L\_j (\V{x}\_t^{(i)} | \V{z}\_{j,t} ) \hat{b}\_t(\V{x}\_t^{(i)})$



---

## 5.4.3 パーティクルの重み

* 尤度をどうパーティクルの分布に反映するか？
    * とりあえず<span style="color:red">重み</span>という変数を付加
* パーティクル（再定義）: $\xi_t^{(i)} = (\V{x}_t^{(i)}, w_t^{(i)})$
    * $\sum_{i=0}^{N-1} w^{(i)} = 1$<br />　
* 次のように信念分布を近似
    * $P(\V{x}\_t^* \in X ) = \int\_{\V{x} \in X} b\_t(\V{x}) d\V{x} \approx \sum\_{i=0}^{N-1} w\_t^{(i)} \delta(\V{x}\_t^{(i)} \in X)$
        * $X$に真の姿勢が含まれる確率をパーティクルの重みつき和で近似<br />　
* 重みの計算
    * $w\_t^{(i)} = L\_j (\V{x}\_t^{(i)} | \V{z}\_{j,t} ) \hat{w}\_t^{(i)}$（あとから正規化）

---

## 5.4.4 尤度関数の決定

* 尤度関数（観測モデル）をどう決めるか
    * シミュレータの実装を見ると分かるが実際のセンサは<br />ブラックボックス
    * 状態遷移モデル同様、実験で

---

### 尤度関数の設計

* 次のような尤度関数を準備
    * $L_j(\V{x} | \V{z}_j) = \mathcal{N}\left[ \V{z} = \V{z}_j | \V{h}_j(\V{x}), Q_j(\V{x}) \right]$
        * $Q_j(\V{x}) = \begin{pmatrix} [\ell_j(\V{x})\sigma_\ell]^2 & 0 \\\\ 0 & \sigma^2_\varphi \end{pmatrix}$
        * $\ell_j(\V{x})$: $\V{x}$とランドマーク$\text{m}_j$の距離
        * $\V{h}_j$: 観測関数<br />　
* 補足
    * 実はシミュレータと同じモデル
        * 本当はセンサ値の統計をとってから決めるべき

---

### センサ値の統計

* 書籍での実験
    * 1000個バイアスが異なるカメラを準備
    * 1[m]先の正面にあるランドマークを1回ずつ観測<br />　
    * 実験の結果、$\sigma_\ell= 0.14$[m/m]、$\sigma_\varphi = 0.05$[rad]に


以後この値を使用するが、これでいいのか？

---

### 実験で統計をとることに関する議論

* 実験で「正しい」状態遷移・観測モデルは得られる？
    * モデルの妥当性の検証や統計の信頼性を上げるためには、もっと条件や実験回数を増やすことが必要
    * 一方、せっかくたくさん実験しても別環境でロボットが動かないことが多い
        * バイアスを考慮しないと顕著に
        * これなら実験結果を無視して分布を広くとったほうがマシ

<span style="color:red">実験で得られるモデルは、実験条件の枠内限定。自律ロボットは枠を超えることを期待される。<br />そこが難しい。<span style="font-size:80%">（人間も然り）</span></span>

---

### ロボットを動かすときのアドバイス

注意: 私見です

* 実験で統計をとらずにモデルを決めてよい
    * 参考になるもの
        * カタログスペック
        * 勘（人間の知識を確率モデルとしてロボットに与える）
        * ロボットの挙動（ちょっと邪魔してもタスクがこなせるかどうか）<br />　
* ロボットが動けばそれでよい
   * <span style="color:red">動くものは結果で評価</span>
   * <span style="color:red">机上の空論よりまずは動かす。人間も然り（危険な場合は除く）</span>
   * ロボティクスが他の学問と一番違う点のような気がします。


---

## 5.4.5 尤度関数の実装

* 作業については書籍を参考に
    * 下図: 重みを矢印の長さで表現したときのパーティクルの挙動
* 問題
    * 正規化していないので重みの和が無限大 or 0に
    * 正規化したとしても重みが一つのパーティクルに偏る

<img width="35%" src="./figs/mcl_sensor_update.gif" />

---

## 5.5 リサンプリング

* 重みの偏りの解決
* やること
    * 重みの大きいパーティクルを複数に分割
    * 一方で、パーティクルの数を一定に保つ<br />　
* 「リサンプリング」という方法で実装
    * サンプリング: アンケートなどをとるときに母集団から<br />標本を選ぶこと
    * リサンプリング: サンプリングされた標本から、<br />標本を使ってもう一度サンプリング<br />
（ややこしいので具体例で説明）

---

## 5.5.1 単純なリサンプリングの<br />実装

* 次のようなリサンプリングのアルゴリズムを考える
    1. パーティクルから一つパーティクルを選ぶ
        * 選ばれる確率 $\propto $重み
    2. 選んだパーティクルのコピーを作成
        * コピーの重みは$1/N$に
    3. 1, 2を$N$回反復。$N$個のコピーを新たなパーティクルの集合に

<img width="50%" src="./figs/resampling.jpg" />

---

### リサンプリングの効果

* 重みの小さいパーティクル<br />$\Longrightarrow$選ばれにくく消失
* 重みの大きいパーティクル<br />$\Longrightarrow$何度も選ばれる
    * 重みは発散せずに抑えられる<br />　
* 効果
    * 重みが偏らず推定が安定
    * 高確率の領域にパーティクルを集中
    * （低確率の部分は打ち切られる）

<img width="38%" src="./figs/mcl_simple_resampling.gif" />

---

### 単純なリサンプリングの問題点

* コピーを作るときの計算量が$O(\log N)$
    * 全体で$O(N \log N)$<br />
$\Longrightarrow$2倍速い計算機を買ってきても<br />パーティクルの数を2倍にできない<br />　
* パーティクルの選び方が偏る
    * 例: 重み$0.2$のパーティクル5個から5個選ぶ場合<br />
$\Longrightarrow$それぞれが1個ずつきれいに選ばれる確率は低い

---

## 5.5.2 系統サンプリングによる<br />リサンプリングの実装

* 方法
    * パーティクルの重みを積み上げたリストを作成
    * $1/N$ずつリストを進んでパーティクルを選んで$N$個コピーを作成
        * 最初の位置だけ乱数で選ぶ
    * コピーの重みを$1/N$にして新たなパーティクルの集合とする

<img width="80%" src="./figs/systematic_sampling.jpg" />

---

### 系統サンプリングの効果

* 左: 単純なリサンプリング
    * 何も観測していないのにパーティクルが複数のクラスタに分離
        * 理由: 重みが同じでも選ばれないパーティクルが発生
* 右: 系統サンプリングによるリサンプリング
    * 全パーティクルの重みが同じなら全て選ばれる


<img width="38%" src="./figs/mcl_simple_resampling.gif" />&nbsp;&nbsp;
<img width="38%" src="./figs/mcl_sys_resampling.gif" />

---

## 5.6 出力の実装

* 推定結果として、センサ値の反映直後で重みが最大の<br />パーティクルの姿勢を返すコードを書く作業
    * あくまで便宜的なもの
    * 本当はパーティクルの分布（信念分布）自体が推定結果<br />　
* 他にパーティクルの姿勢の平均値を返す方法もある
    * 分布が二つ以上の集団に分かれていると不適切な結果を返す

結局、分布から姿勢を一つ決めることはできない<br />$\Longrightarrow$12章のPOMDPでこのテーマを扱う

---

## 5.7 まとめ

* ベイズフィルタを導出<br />　
* MCLというアルゴリズムでベイズフィルタを実装
    * サンプリングに関するアルゴリズムを駆使<br />　
* 「正しい状態遷移モデル、観測モデル」に対する考察
    * 動かしたい環境でロボットが動くモデルが良いモデル
    * 実験室でチューニングの果てに得た精度には意義があまりないので論文を読むときに注意
